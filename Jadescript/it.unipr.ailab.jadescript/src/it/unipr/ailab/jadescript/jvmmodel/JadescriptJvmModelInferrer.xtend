/*
 * generated by Xtext 2.12.0
 */
package it.unipr.ailab.jadescript.jvmmodel

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import it.unipr.ailab.jadescript.jadescript.Agent
import it.unipr.ailab.jadescript.jadescript.Behaviour
import it.unipr.ailab.jadescript.jadescript.GlobalFunctionOrProcedure
import it.unipr.ailab.jadescript.jadescript.Model
import it.unipr.ailab.jadescript.jadescript.Ontology
import it.unipr.ailab.jadescript.semantics.SemanticsModule
import it.unipr.ailab.jadescript.semantics.context.ContextManager
import it.unipr.ailab.jadescript.semantics.topelement.AgentDeclarationSemantics
import it.unipr.ailab.jadescript.semantics.topelement.BehaviourTopLevelDeclarationSemantics
import it.unipr.ailab.jadescript.semantics.topelement.GlobalOperationDeclarationSemantics
import it.unipr.ailab.jadescript.semantics.topelement.OntologyDeclarationSemantics
import it.unipr.ailab.maybe.Maybe
import java.util.ArrayList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmAnnotationReferenceBuilder
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import it.unipr.ailab.jadescript.jadescript.TopElement

/**
 * @author Giuseppe Petrosino - giuseppe.petrosino@unimore.it
 * 
 * @author Eleonora Iotti - eleonora.iotti@studenti.unipr.it
 * @author Andrea Segalini - andrea.segalini@studenti.unipr.it
 */
class JadescriptJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	/**
	 * API to get the fully qualified name of an EObject.
	 */
	@Inject extension IQualifiedNameProvider

	/**
	 * Some utilities.
	 */
	@Inject extension JadescriptCompilerUtils
	@Inject extension JvmAnnotationReferenceBuilder

	def boolean areAllLinkingErrors(EList<Resource.Diagnostic> errors) {
		return new ArrayList<Resource.Diagnostic>(errors).stream().allMatch [
			it.message.endsWith("cannot be resolved to a type.")
		]
	}

	def SemanticsModule createSemanticsModuleAndEnterFile(Model model, boolean isPreIndexingPhase) {
		var String phase
			if (isPreIndexingPhase) {
				phase = "Preindexing"
			} else {
				phase = "Compile"
			}
		var module = new SemanticsModule(
			phase,
			_jvmTypesBuilder,
			_typeReferenceBuilder,
			_jvmAnnotationReferenceBuilder,
			_iQualifiedNameProvider,
			_jadescriptCompilerUtils
		)
		var String moduleName
		if (model.isWithModule) {
			moduleName = model.name
		} else {
			moduleName = ""
		}
		module.get(ContextManager).enterModule(moduleName, Maybe.some(model))
		module.get(ContextManager).enterFile(
			model.eResource.URI.toString,
			model.eResource.URI.trimFileExtension.lastSegment,
			Maybe.some(model.importSection)
				.__[it.importSection]
				.__toList[it.importDeclarations]
		)

		return module
	}

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		try {
			var functionsMap = HashMultimap.create
			var others = new ArrayList<TopElement>

			for (element : model.elements) {
				switch (element) {
					GlobalFunctionOrProcedure:
						functionsMap.put(element.name, element)
					default:
						others.add(element)
				}
			}

			

			for (k : functionsMap.keySet) {
				var module = createSemanticsModuleAndEnterFile(model, isPreIndexingPhase)

				var gms = module.get(GlobalOperationDeclarationSemantics)
				for (v : functionsMap.get(k)) {
					gms.addMethod(Maybe.some(v))

				}
				gms.generateDeclaredTypes(gms.getOriginalMethod(k), acceptor, isPreIndexingPhase)
			}


			for (element : others) {
				infer(element, acceptor, isPreIndexingPhase)
			}

		} catch (RuntimeException ex) {
			ex.printStackTrace
		}
	}
	
	def dispatch void infer(Behaviour behaviour, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val model = EcoreUtil2.getContainerOfType(behaviour, Model)
		var module = createSemanticsModuleAndEnterFile(model, isPreIndexingPhase)
		module.get(BehaviourTopLevelDeclarationSemantics).generateDeclaredTypes(
			Maybe.some(behaviour),
			acceptor,
			isPreIndexingPhase
		)
	}
	
	def dispatch void infer(Ontology ontology, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val model = EcoreUtil2.getContainerOfType(ontology, Model)
		var module = createSemanticsModuleAndEnterFile(model, isPreIndexingPhase)
		module.get(OntologyDeclarationSemantics).generateDeclaredTypes(
			Maybe.some(ontology),
			acceptor,
			isPreIndexingPhase
		)
	}
	
	def dispatch void infer(Agent agent, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val model = EcoreUtil2.getContainerOfType(agent, Model)
		var module = createSemanticsModuleAndEnterFile(model, isPreIndexingPhase)
		module.get(AgentDeclarationSemantics).generateDeclaredTypes(
			Maybe.some(agent),
			acceptor,
			isPreIndexingPhase
		)
	}

}
