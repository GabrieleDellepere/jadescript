/*
 * generated by Xtext 2.12.0
 */
package it.unipr.ailab.jadescript.jvmmodel

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import it.unipr.ailab.jadescript.jadescript.Agent
import it.unipr.ailab.jadescript.jadescript.Behaviour
import it.unipr.ailab.jadescript.jadescript.GlobalFunctionOrProcedure
import it.unipr.ailab.jadescript.jadescript.Model
import it.unipr.ailab.jadescript.jadescript.Ontology
import it.unipr.ailab.jadescript.jadescript.TopElement
import it.unipr.ailab.jadescript.semantics.SemanticsModule
import it.unipr.ailab.jadescript.semantics.topelement.AgentSemantics
import it.unipr.ailab.jadescript.semantics.topelement.GlobalMethodSemantics
import it.unipr.ailab.jadescript.semantics.topelement.OntologySemantics
import it.unipr.ailab.jadescript.semantics.topelement.TopElementBehaviourSemantics
import it.unipr.ailab.maybe.Maybe
import java.util.ArrayList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.xtext.xbase.jvmmodel.JvmAnnotationReferenceBuilder
import it.unipr.ailab.jadescript.semantics.context.ContextManager
import org.eclipse.xtext.EcoreUtil2

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>
 * 
 * @author Eleonora Iotti - eleonora.iotti@studenti.unipr.it
 * 
 * @author Giuseppe Petrosino - giuseppe.petrosino@studenti.unipr.it
 * @author Andrea Segalini - andrea.segalini@studenti.unipr.it
 * 
 * 
 * 
 */
class JadescriptJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	/**
	 * API to get the fully qualified name of an EObject.
	 */
	@Inject extension IQualifiedNameProvider

	/**
	 * Some utilities.
	 */
	@Inject extension JadescriptCompilerUtils

	@Inject extension JvmAnnotationReferenceBuilder

	def boolean areAllLinkingErrors(EList<Resource.Diagnostic> errors) {
		return new ArrayList<Resource.Diagnostic>(errors).stream().allMatch [
			it.message.endsWith("cannot be resolved to a type.")
		]
	}

	def SemanticsModule createSemanticsModule(Model model, String phase) {
		var module = new SemanticsModule(phase, _jvmTypesBuilder, _typeReferenceBuilder, _jvmAnnotationReferenceBuilder,
			_iQualifiedNameProvider, _jadescriptCompilerUtils)
		var String moduleName
		if (model.isWithModule) {
			moduleName = model.name
		} else {
			moduleName = ""
		}
		module.get(ContextManager).enterModule(moduleName, Maybe.some(model))
		module.get(ContextManager).enterFile(
			model.eResource.URI.toString,
			model.eResource.URI.trimFileExtension.lastSegment,
			Maybe.toListOfMaybes(
				Maybe.some(model.importSection).__[it.importSection].__[it.importDeclarations]
			)
		)

		return module
	}

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		try {
			var functionsMap = HashMultimap.create
			var agents = new ArrayList<Agent>
			var ontologies = new ArrayList<Ontology>
			var others = new ArrayList<TopElement>

			for (element : model.elements) {
				switch (element) {
					GlobalFunctionOrProcedure:
						functionsMap.put(element.name, element)
					Agent:
						agents.add(element)
					Ontology:
						ontologies.add(element)
					default:
						others.add(element)
				}
			}

			var String phase
			if (isPreIndexingPhase) {
				phase = "Preindexing"
			} else {
				phase = "Compile"
			}

			for (k : functionsMap.keySet) {
				var module = createSemanticsModule(model, phase)

				var gms = module.get(GlobalMethodSemantics)
				for (v : functionsMap.get(k)) {
					gms.addMethod(Maybe.some(v))

				}
				gms.generateDeclaredTypes(gms.getOriginalMethod(k), acceptor, isPreIndexingPhase)
			}

			for (ontology : ontologies) {
				var module = createSemanticsModule(model, phase)
				module.get(OntologySemantics).generateDeclaredTypes(Maybe.some(ontology), acceptor, isPreIndexingPhase)

			}

			for (agent : agents) {
				var module = createSemanticsModule(model, phase)
				module.get(AgentSemantics).generateDeclaredTypes(Maybe.some(agent), acceptor, isPreIndexingPhase)

			}

			for (element : others) {
				var module = createSemanticsModule(model, phase)
				switch (element) {
					Behaviour:
						switch (element as Behaviour) {
							Behaviour:
								module.get(TopElementBehaviourSemantics).generateDeclaredTypes(
									Maybe.some(element as Behaviour),
									acceptor,
									isPreIndexingPhase
								)
						}
				}
			}

		} catch (RuntimeException ex) {
			ex.printStackTrace
		}
	}

}
